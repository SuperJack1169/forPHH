အခန်း ၆ – Commits (စွဲချက်များ)

Git မှာ commit ဆိုတာ repository မှာ ပြောင်းလဲမှုတွေကို မှတ်တမ်းတင်ဖို့ အသုံးပြုတဲ့ နည်းလမ်းတစ်ခုပါ။

ပုံမှန်ရုပ်ပုံအတိုင်းသာကြည့်ရင် Git commit ဟာ အခြား VCS (version control systems) တွေမှာရှိတဲ့ commit သို့မဟုတ် check-in တွေနဲ့ မတူတာမရှိသလိုထင်ရပေမယ့်၊ Git အတွင်းထဲမှာတော့ သူ့ရဲ့လုပ်ဆောင်ပုံက ထူးခြားသလောက်ထူးခြားပါတယ်။

commit တစ်ခုပြုလုပ်တဲ့အချိန်မှာ Git ဟာ index ထဲက snapshot ကိုယူပြီး object store ထဲသို့ သိမ်းဆည်းပါတယ်။ (index ကို commit ပြင်ဆင်တဲ့အကြောင်းကိုတော့ Chapter 5 မှာ ဖော်ပြထားပါတယ်။) ဒီ snapshot ဟာ index ထဲက file နဲ့ directory တွေအကုန်လုံးကို တစ်ပြားပြားကူးယူထားတာမဟုတ်ပါဘူး။ ဒါကြောင့် storage ပမာဏအရမ်းကြီးလိုအပ်သွားမှာဖြစ်ပါတယ်။ ထိုအစား Git က index ရဲ့ လက်ရှိအခြေအနေကို ယခင် snapshot နဲ့ နှိုင်းယှဉ်ပြီး ပြောင်းလဲနေတဲ့ file နဲ့ directory များကို စာရင်းထုတ်ပါတယ်။ ပြောင်းလဲသွားတဲ့ file တစ်ခုစီအတွက်တော့ Git က အသစ်ဖြစ်တဲ့ blob ကိုဖန်တီးပြီး၊ ပြောင်းလဲသွားတဲ့ directory များအတွက် tree အသစ်ဖန်တီးတယ်။ မပြောင်းလဲတဲ့ blob နဲ့ tree တွေကတော့ အရင်ကအတိုင်း အသုံးပြုနေတယ်။

commit snapshot တွေဟာ တစ်ခုနောက်တစ်ခု ဆက်သွယ်ထားပြီး၊ commit အသစ်တိုင်းဟာ သူ့ရဲ့ ယခင် commit (predecessor) ကိုညွှန်ပြထားပါတယ်။ အချိန်အတော်ကြာလာတဲ့အခါမှာ ပြောင်းလဲမှုတွေရဲ့စဉ်ဆက်ကို commit စုပေါင်းတစ်ခုအနေနဲ့ ကိုယ်စားပြုလာပါတယ်။

index အားလုံးကို ယခင် snapshot တစ်ခုနဲ့ နှိုင်းယှဉ်ဖို့ဆိုတာ သိပ်ကုန်ကြေးကြီးမယ်ထင်ရပေမယ့်၊ Git မှာတော့ ဒီလုပ်ဆောင်မှုဟာ အလွန်မြန်ဆန်ပါတယ်။ ဒါဟာ Git object တစ်ခုချင်းစီမှာ SHA1 hash တန်ဖိုးရှိတာကြောင့်ဖြစ်ပါတယ်။ object နှစ်ခု (subtree နှစ်ခုတောင်ဖြစ်နိုင်တယ်) မှာ SHA1 တူတယ်ဆိုရင်၊ အဲဒီ object တွေက တစ်ခုတည်းပဲ ဖြစ်တာဖြစ်ပါတယ်။ ဒါကြောင့် Git ဟာ recursive compare များစွာကိုရှောင်ရှားပြီး အတူတူဖြစ်နေတဲ့ subtree များကို ဖြတ်ပြီး မလုပ်တော့တာကြောင့် မြန်ဆန်တာပါ။

repository ထဲမှာ ပြောင်းလဲမှုတစ်ခု တိုင်းဟာ commit တစ်ခုပဲဖြစ်နိုင်တယ်။ ပြောင်းလဲမှုတစ်ခုတင်ထည့်ချင်တယ်ဆိုရင်တော့ commit ပြုလုပ်ရပါမယ်။ ဒါကြောင့် repository ထဲမှာ ပြောင်းလဲမှုတစ်ခုရှိလာတဲ့အခါမှာ သူ့ရဲ့မှတ်တမ်း(commit) မရှိဘူးဆိုတာမျိုး မဖြစ်သင့်ပါဘူး။
စဉ်းစားကြည့်ပါ။ master repository ထဲကအကြောင်းအရာတစ်ခု ပြောင်းလဲသွားတယ်။ ဒါဘယ်လိုဖြစ်သွားတာလဲ၊ ဘယ်သူလုပ်တာလဲ၊ ဘာကြောင့်လုပ်တာလဲဆိုတာကို မှတ်တမ်းမရှိတော့ဘူးဆိုရင် ဘယ်လောက်ရှုပ်ထွေးနိုင်လဲ?

ပုံမှန်အားဖြင့် commit တေ့ာကို developer တွေက manual နဲ့လုပ်တာဖြစ်ပေမယ့်၊ Git ကိုယ်တိုင်က commit တစ်ခုဖန်တီးနိုင်ပါတယ်။ Chapter 9 မှာ ကြည့်ရင် merge operation တစ်ခုပြုလုပ်တဲ့အချိန်မှာလည်း Git က ကိုယ့် users မပြုလုပ်ခင်ပဲ commit တစ်ခုဖန်တီးပါတယ်။

သင့်အနေနဲ့ ဘယ်အချိန်မှာ commit ပြုလုပ်မလဲဆိုတာက မင်းရဲ့လုပ်ဆောင်သဘောထားနဲ့ dev style အပေါ်မူတည်ပါတယ်။ ဒါပေမယ့် ရိုးရိုးအကြံပြုချက်အနေနဲ့ – test suite pass ပြီးတဲ့အချိန်၊ ရုံးပိတ်ချိန်၊ နောက်တစ်ဆင့်တိုးဖို့အဆင်သင့်ဖြစ်တဲ့အချိန် – commit တစ်ခုလုပ်လိုက်တာကောင်းပါတယ်။

သို့သော် commit လုပ်ဖို့ မမြန်ပါနဲ့ဆိုတာမဟုတ်ပါဘူး။ Git ဟာ frequent commits ကို သဘောတူပါတယ်။ commits တွေကို စီမံဖို့အတွက် commands တွေအများကြီးရှိပါတယ်။ နောက် Chapters တွေမှာ ကြည့်ရင်လည်း များပြားတဲ့ commits (အသေးစား ပြောင်းလဲမှုတွေပါတဲ့) တွေဟာ patch sets တွေကို တိကျအောင် ခွဲခြမ်းစီမံဖို့အဆင်ပြေစေတယ်။